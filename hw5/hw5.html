<!DOCTYPE html>
<html>

<head>
    <title>Chart Simulation</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
    <link href="rectCss.css" rel="stylesheet"/>

</head>

<body>
    <h1>Chart Simulation</h1>
    <label for="systemsCount">Systems Count: </label>
    <input type="number" id="systemsCount" value="10"><br>
    <label for="subIntervals">Sub-Intervals: </label>
    <input type="number" id="subIntervals" value="50"><br>
    <label for="lambda">Lambda: </label>
    <input type="number" id="lambda" value="0.1"><br>
    <button id="calculateButton">Calculate</button><br>
    
    <div class="container">
    <canvas id="chartCanvas" width="800" height="400"></canvas>
    </div>
    <script>
        const chartCanvas = document.getElementById('chartCanvas');
        const ctx = chartCanvas.getContext('2d');
        const chartWidth = chartCanvas.width;
        const chartHeight = chartCanvas.height;

        const systemsCountInput = document.getElementById('systemsCount');
        const subIntervalsInput = document.getElementById('subIntervals');
        const lambdaInput = document.getElementById('lambda');
        const calculateButton = document.getElementById('calculateButton');

        let systemsCount = parseInt(systemsCountInput.value, 10);
        let subIntervals = parseInt(subIntervalsInput.value, 10);
        let lambda = parseFloat(lambdaInput.value);

        calculateButton.addEventListener('click', () => {
            systemsCount = parseInt(systemsCountInput.value, 10);
            subIntervals = parseInt(subIntervalsInput.value, 10);
            lambda = parseFloat(lambdaInput.value);
            calculateScores();
            draw();
        });

        let scaleX = 50;
        let scaleY = 50;
        let chartX = 0;
        let chartY = 0;
        let cartesianZoom = 1.0;

        let drawingData = [];
        let firstHalf = 0;
        let secondHalf = 0;

        function generateRandomColors(count) {
            const randomColor = () => Math.floor(Math.random() * 256);
            const colors = [];

            for (let i = 0; i < count; i++) {
                colors.push(`rgb(${randomColor()}, ${randomColor()}, ${randomColor()})`);
            }

            return colors;
        }

        let systemColors = generateRandomColors(systemsCount);


        function calculateScores() {
            drawingData = new Array(systemsCount).fill([]);
            firstHalf = 0;
            secondHalf = 0;

            for (let currentSystem = 0; currentSystem < systemsCount; currentSystem++) {
                const systemData = [{ x: 0, y: 0 }];
                drawingData[currentSystem] = systemData;

                for (let subInterval = 1; subInterval <= subIntervals; subInterval++) {
                    const successProbability = Math.random();

                    if (successProbability > (lambda / subIntervals)) {
                        if (subInterval <= subIntervals / 2) {
                            firstHalf++;
                            secondHalf++;
                        } else {
                            secondHalf++;
                        }
                        systemData.push({ x: subInterval, y: systemData[systemData.length - 1].y });
                        systemData.push({ x: subInterval, y: systemData[systemData.length - 1].y + 1 });
                    } else {
                        systemData.push({ x: subInterval, y: systemData[systemData.length - 1].y });
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, chartWidth, chartHeight);

            const stepX = scaleX * cartesianZoom;
            const stepY = scaleY * cartesianZoom;
            const originX = chartX;
            const originY = chartY;
            const pointsCountX = Math.floor(chartWidth / stepX);
            const pointsCountY = Math.floor(chartHeight / stepY);

            ctx.beginPath();
            ctx.moveTo(originX, chartHeight);
            ctx.lineTo(chartWidth, chartHeight);
            ctx.strokeStyle = 'black'
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX, chartHeight);
            ctx.strokeStyle = 'black'
            ctx.stroke();

            for (let system = 0; system < systemsCount; system++) {
                ctx.beginPath();

                for (let point = 0; point < drawingData[system].length - 1; point++) {
                    const startX = drawingData[system][point].x * scaleX * cartesianZoom + chartX;
                    const startY = chartHeight - drawingData[system][point].y * scaleY * cartesianZoom;
                    const endX = drawingData[system][point + 1].x * scaleX * cartesianZoom + chartX;
                    const endY = chartHeight - drawingData[system][point + 1].y * scaleY * cartesianZoom;
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                }

                ctx.strokeStyle = systemColors[system];
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            drawHistograms();
        }

        function drawHistograms() {
            const barWidth = 10.0 / 5.0 * scaleX * cartesianZoom;
            const startXFirstSeries = (subIntervals / 2) * scaleX * cartesianZoom + chartX;
            const startXSecondSeries = subIntervals * scaleX * cartesianZoom + chartX;
            const initialY = chartHeight;
            const normalizedFirstScore = firstHalf / systemsCount;
            const normalizedSecondScore = secondHalf / systemsCount;
            const initialHeight = 4 * scaleY * cartesianZoom;
            const firstBarHeight = normalizedFirstScore * scaleY * cartesianZoom;
            const secondBarHeight = normalizedSecondScore * scaleY * cartesianZoom;
            const yFirstSeries = chartHeight - firstBarHeight;
            const ySecondSeries = chartHeight - secondBarHeight;

            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.fillRect(startXFirstSeries, yFirstSeries, barWidth, firstBarHeight);

            ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
            ctx.fillRect(startXSecondSeries, ySecondSeries, barWidth, secondBarHeight);

            ctx.font = '16px Arial';
            ctx.fillStyle = 'black';
            ctx.fillText(firstHalf.toString(), startXFirstSeries + barWidth, yFirstSeries + firstBarHeight / 2);
            ctx.fillText(secondHalf.toString(), startXSecondSeries + barWidth, ySecondSeries + secondBarHeight / 2);
        }

        calculateScores();
        draw();


    </script>
</body>

<script src="rectScript.js"></script>
</html>